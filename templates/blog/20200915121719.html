<h2>ディープラーニングで初期入力から最終出力を得る計算過程</h2>

ディープラーニングで初期入力から最終出力を得る計算過程について解説します。

前提として、<a href="/blog/20200913103640.html">ベクトルの和を求める計算</a>と<a href="/blog/20200914103640.html">行列の積を求める計算</a>を理解しておいてください。

<h3>入力層と隠れ層と出力層の関係</h3>

ディープラーニングの解説では、入力層と隠れ層と出力層の図が必ずでてきます。ただし、この図は、概念的な図であって、実際のプログラムにおけるデータ構造を適切に表現しているわけではありません。

プログラムを書く上で、知っておかなければならない情報は、次の３つです。

「入力数」と「隠れ層の各層のニューロン数」と「出力数」です。

個々のデータはすべて32bit浮動小数点で表現されます。C言語でいうところのfloat型です。

<h4>入力数</h4>

28ピクセル×28ピクセルのモノクロ画像の場合は、float型の784個の入力数です。色の濃さは0～255で表現できるので、float型の値として表現できます。float型は浮動小数点型ですが、小数点を使わないことによって、整数も表現できます。

<h4>隠れ層の各層のニューロンの数</h4>

隠れ層のニューロン数は、自分で決めます。3層あったとすると1層目は100、2層目は150、3層目は120のように任意で決めます。

<h4>出力数</h4>

出力数は、たとえばパターン認識の場合で、A、B、Cを判定するとすると、3になります。

<h3>隠れ層の各層の情報</h3>

次に隠れ層の各層の情報について書きます。隠れ層の各層は、重みとバイアスと呼ばれるパラメーターを持っています。これは、<a href="/blog/20200302113052.html">m個の入力をn個の出力に変換</a>するためのものです。

重みは行列として表現されます。バイアスは、ベクトルとして表現されます。

<h4>重みとバイアスを使って入力から出力を求める計算</h4>

2つの入力を、重みとバイアスを使って、3つの出力に変換するPerlのコードです。これは、行列を使うと簡潔に求められます。add_vecは行列の和、mul_mutは、行列の積を求める関数だと考えてください。

重みは、3×2の列優先の行列だと考えてください。

<pre>
# 実際の処理の詳細
$outputs->[0] = $weights->[0] * $inputs->[0] + $weights->[3] * $inputs->[1] + $biases->[0];
$outputs->[1] = $weights->[1] * $inputs->[0] + $weights->[4] * $inputs->[1] + $biases->[1];
$outputs->[2] = $weights->[2] * $inputs->[0] + $weights->[5] * $inputs->[1] + $biases->[2];

# 行列での表現
$outputs = add_vec(mul_mut($weights, $inputs), $biases);
</pre>

数学の式を見ると、頭が混乱してきますが、単なる掛け算・足し算・関数呼び出しと考えると簡単ですね。

